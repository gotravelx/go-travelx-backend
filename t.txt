import Web3 from "web3";
import schedule from "node-schedule";
import FlightData from "../model/flight.js";
import https from "https";
import ContractAbi from "../utils/abi.js";
import dotenv from "dotenv";
import { fetchFlightFromDataSource } from "./datasource.js";

dotenv.config();

const agent = new https.Agent({
  rejectUnauthorized: false,
});

const PRIMARY_CAMINO_PROVIDER = process.env.PRIMARY_CAMINO_PROVIDER; // Example: Infura RPC URL
const PRIVATE_KEY = process.env.PRIVATE_KEY; // Your Wallet Private Key
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS; // Your Smart Contract Address
// Create HTTPS agent to disable certificate validation

console.log(
  "PRIMARY_CAMINO_PROVIDER",
  PRIMARY_CAMINO_PROVIDER,
  "PRIVATE_KEY",
  PRIVATE_KEY,
  "CONTRACT_ADDRESS",
  CONTRACT_ADDRESS
);

// Initialize Web3
const web3 = new Web3(new Web3.providers.HttpProvider(PRIMARY_CAMINO_PROVIDER));

// Create contract instance
const contract = new web3.eth.Contract(ContractAbi, CONTRACT_ADDRESS);

// Get account from private key
const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
web3.eth.accounts.wallet.add(account);
// Search flight data from both blockchain and MongoDB
export const searchFlight = async (req, res) => {
  try {
    const { flightNumber, flightOriginationDate, operatingAirline } = req.body;
    console.log(
      `[REQUEST] Search request for flight ${flightNumber} on date ${flightOriginationDate}`
    );

    // Format date if provided, otherwise use current date
    const searchDate = flightOriginationDate
      ? new Date(flightOriginationDate)
      : new Date();
    const formattedDate = searchDate.toISOString().split("T")[0];

    // Try to get data from MongoDB first (faster)
    const dbFlight = await FlightData.findOne({
      flightNumber: parseInt(flightNumber),
      flightOriginationDate: { $regex: formattedDate },
      operatingAirline: operatingAirline,
    }).sort({ updatedAt: -1 });

    // If found in MongoDB, return the data
    if (dbFlight) {
      console.log(`[SEARCH] Found flight ${flightNumber} in MongoDB`);
      return res.status(200).json({
        source: "mongodb",
        data: dbFlight,
      });
    }

    // If not in MongoDB, try to get from blockchain
    try {
      console.log(
        `[SEARCH] Flight ${flightNumber} not found in MongoDB, checking blockchain...`
      );

      // Check if user has a valid subscription
      const walletAddress = accounts[0]; // Replace with actual user wallet address
      const subscription = await flightStatusContract.methods
        .subscriptions(walletAddress)
        .call();

      const currentTimestamp = Math.floor(Date.now() / 1000);

      if (subscription > currentTimestamp) {
        // Get flight data from blockchain
        console.log(
          `[BLOCKCHAIN] Retrieving flight ${flightNumber} data from blockchain...`
        );

        const blockchainFlight = await flightStatusContract.methods
          .getFlightDetails(
            flightNumber,
            flightOriginationDate,
            operatingAirline
          )
          .call({ from: walletAddress });

        if (blockchainFlight && blockchainFlight.flightNumber) {
          console.log(
            `[BLOCKCHAIN] Successfully retrieved flight ${flightNumber} from blockchain`
          );

          // Get UTC times
          const utcTimes = await flightStatusContract.methods
            .UtcTimes(flightNumber, flightOriginationDate, operatingAirline)
            .call();

          // Get status
          const status = await flightStatusContract.methods
            .getFlightStatus(
              flightNumber,
              flightOriginationDate,
              operatingAirline
            )
            .call({ from: walletAddress });

          // Format data
          const flightData = {
            flightNumber: parseInt(blockchainFlight.flightNumber),
            flightOriginationDate: formattedDate,
            operatingAirline: blockchainFlight.operatingAirline,
            departureCity: blockchainFlight.departureCity,
            arrivalCity: blockchainFlight.arrivalCity,
            departureGate: blockchainFlight.departureGate,
            arrivalGate: blockchainFlight.arrivalGate,
            flightStatus: status,
            equipmentModel: blockchainFlight.equipmentModel,
            estimatedArrivalUTC: utcTimes.estimatedArrivalUTC,
            estimatedDepartureUTC: utcTimes.estimatedDepartureUTC,
            actualArrivalUTC: utcTimes.actualArrivalUTC,
            actualDepartureUTC: utcTimes.actualDepartureUTC,
            scheduledArrivalUTCDateTime: utcTimes.scheduledArrivalUTC,
            scheduledDepartureUTCDateTime: utcTimes.scheduledDepartureUTC,
            blockchainStatus: "success",
            retrievedFrom: "blockchain",
          };

          // Save to MongoDB for future queries with blockchain info
          console.log(
            `[MONGODB] Saving blockchain-retrieved flight ${flightNumber} to MongoDB`
          );
          const newFlight = new FlightData(flightData);
          await newFlight.save();

          return res.status(200).json({
            source: "blockchain",
            data: flightData,
          });
        }
      } else {
        // If no subscription, note this in the response
        console.log(
          `[BLOCKCHAIN] No valid blockchain subscription for accessing flight ${flightNumber}`
        );
      }
    } catch (blockchainError) {
      console.error(
        `[BLOCKCHAIN ERROR] Error fetching flight ${flightNumber} from blockchain:`,
        blockchainError.message
      );
      // Continue to external API if blockchain fails
    }

    // If not found in either database, fetch from external API
    console.log(
      `[SEARCH] Flight ${flightNumber} not found in local sources, fetching from external API...`
    );
    try {
      const apiResponse = await fetchFlightFromDataSource(
        flightNumber,
        flightOriginationDate,
        operatingAirline
      );
      return res.status(200).json({
        source: "external_api",
        data: apiResponse,
      });
    } catch (apiError) {
      console.error(
        `[API ERROR] Failed to fetch flight ${flightNumber} from external API:`,
        apiError.message
      );
      throw apiError;
    }
  } catch (error) {
    console.error(
      `[ERROR] Error searching flight data for ${req.body?.flightNumber}:`,
      error.message
    );
    if (error.response) {
      console.error("[ERROR] Error response:", error.response.data);
    }
    res.status(502).json({
      error: "Failed to fetch flight data",
      details: error.message,
      timestamp: new Date().toISOString(),
    });
  }
};

// Start flight status monitoring
export const startFlightStatusMonitoring = () => {
  // Run every 5 minutes
  const job = schedule.scheduleJob("*/5 * * * *", async () => {
    try {
      console.log(
        "[SCHEDULER] Running scheduled flight status update check..."
      );

      // Get flights updated in the last 24 hours
      const oneDayAgo = new Date();
      oneDayAgo.setDate(oneDayAgo.getDate() - 1);

      const recentFlights = await FlightData.find({
        updatedAt: { $gte: oneDayAgo },
      }).sort({ updatedAt: -1 });

      console.log(
        `[SCHEDULER] Found ${recentFlights.length} recent flights to check for updates`
      );

      // Track results
      const results = {
        total: recentFlights.length,
        updated: 0,
        failed: 0,
        skipped: 0,
        blockchainUpdated: 0,
      };

      // Check each flight for updates
      for (const flight of recentFlights) {
        try {
          // Skip already arrived flights
          if (flight.phase === "in" || flight.statusCode === "IN") {
            console.log(
              `[SCHEDULER] Skipping already arrived flight ${flight.flightNumber} for ${flight.flightOriginationDate}`
            );
            results.skipped++;
            continue;
          }

          // Fetch latest data
          const newFlightData = await fetchFlightFromDataSource(
            flight.flightNumber,
            flight.flightOriginationDate,
            flight.operatingAirline
          );

          // Status progression update logic
          let shouldUpdate = false;
          let updateData = {};

          // not_departed -> out
          if (
            flight.phase === "not_departed" &&
            newFlightData.phase === "out"
          ) {
            shouldUpdate = true;
            updateData = {
              ...newFlightData,
              phase: "out",
              blockchainUpdated: false,
            };
          }
          // out -> off
          else if (flight.phase === "out" && newFlightData.phase === "off") {
            shouldUpdate = true;
            updateData = {
              ...newFlightData,
              phase: "off",
              blockchainUpdated: false,
            };
          }
          // off -> on
          else if (flight.phase === "off" && newFlightData.phase === "on") {
            shouldUpdate = true;
            updateData = {
              ...newFlightData,
              phase: "on",
              blockchainUpdated: false,
            };
          }
          // on -> in
          else if (flight.phase === "on" && newFlightData.phase === "in") {
            shouldUpdate = true;
            updateData = {
              ...newFlightData,
              phase: "in",
              blockchainUpdated: false,
            };
          }

          // Perform update if conditions are met
          if (shouldUpdate) {
            console.log(
              `[SCHEDULER] Updating flight ${flight.flightNumber} for ${flight.flightOriginationDate}`
            );

            // Prepare data for blockchain insertion
            const blockchainFlightData = [
              flight.flightNumber,
              flight.flightOriginationDate,
              flight.carrierCode,
              flight.arrivalCity,
              flight.departureCity,
              flight.operatingAirline,
              flight.arrivalGate,
              flight.departureGate,
              newFlightData.statusCode,
              flight.equipmentModel,
            ];

            const blockchainUtcTimes = [
              newFlightData.actualArrivalUTC || "",
              newFlightData.actualDepartureUTC || "",
              newFlightData.estimatedArrivalUTC || "",
              newFlightData.estimatedDepartureUTC || "",
              newFlightData.scheduledArrivalUTC || "",
              newFlightData.scheduledDepartureUTC || "",
            ];

            const blockchainStatus = [
              newFlightData.statusCode,
              newFlightData.statusDescription || "",
              newFlightData.outTimeUTC || "",
              newFlightData.offTimeUTC || "",
              newFlightData.onTimeUTC || "",
              newFlightData.inTimeUTC || "",
            ];

            try {
              // Insert flight details into blockchain
              await flightStatusContract.methods
                .insertFlightDetails(
                  blockchainFlightData,
                  blockchainUtcTimes,
                  blockchainStatus
                )
                .send({ from: accounts[0] }); // Use first account

              updateData.blockchainUpdated = true;
              results.blockchainUpdated++;
            } catch (blockchainError) {
              console.error(
                `[BLOCKCHAIN ERROR] Failed to update blockchain for flight ${flight.flightNumber}:`,
                blockchainError
              );
            }

            // Update in MongoDB
            await FlightData.findByIdAndUpdate(flight._id, updateData);

            console.log(
              `[SCHEDULER] Successfully updated flight ${flight.flightNumber} from ${flight.phase} to ${updateData.phase}`
            );
            results.updated++;
          } else {
            console.log(
              `[SCHEDULER] No update needed for flight ${flight.flightNumber}`
            );
          }
        } catch (flightError) {
          console.error(
            `[SCHEDULER ERROR] Error updating flight ${flight.flightNumber}:`,
            flightError.message
          );
          results.failed++;
        }
      }

      console.log(
        `[SCHEDULER] Scheduled flight status update completed. Results: ${JSON.stringify(
          results
        )}`,
        new Date()
      );
    } catch (error) {
      console.error(
        `[SCHEDULER ERROR] Error in scheduled flight status update:`,
        error.message
      );
    }
  });

  console.log(
    "[SCHEDULER] Flight status monitoring started - checking every 5 minutes"
  );
  return job;
};

// Initialize and start monitoring
startFlightStatusMonitoring();

export default {
  searchFlight,
};
